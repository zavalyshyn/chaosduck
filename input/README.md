## Hardening techniques

**Hardening techniques explored**:

1. Loop hardening (T0)
2. Statement Counters (T1)
3. Duplicated Functions (T2)
4. Decryption at Place (T3)
5. Duplicated Variables (T4)

## Overview

**Loop Hardening (T0)**: the counters for sensitive loops are duplicated and incremented at each loop. On loop exit the value of a duplicated counter as well as an exit condition are verified. If a duplicated counter has a value different from the main main counter or the exit condition does not hold an error is raised.

**Statement Counters (T1)**: implements a control-flow graph (CFG) hardening technique proposed in [1]. Each statement of the source code is counted as it is executed. After each statement the counter is compared with the expected value. In case of a mismatch an error is raised. Each code block (e.g. function call, if/else/then statements or a for/while loop) has its own statement counters.

**Duplicated Functions (T2)**: sensitive functions are duplicated and their results are compared before the final output.

**Decryption at Place (T3)**: the cipher is decrypted and compared with an original plaintext at place before the final output.

**Duplicated Variables (T4)**: each source code variable is duplicated and every write operation performed on the original variable is also carried on its duplicate. After each read operation the original and a duplicated variables are compared.



## Hardening techniques statistics

**Encryption algorithm**: PRESENT6480 (64 bits plaintext and 80 bits key) size-optimized 32bit.

On a **source code level** the hardening techniques introduce the following overhead to the original code.

.

| Hardening technique       | LOC | Overhead (%) | Size (bytes) | Overhead (%) |
| ------------------------- | --- | :----------: | ------------ | ------------ |
| Original (no harden.)     | 180 |     n/a      |     5615     |   n/a        |
| T0. Loop Hardening        | 250 |     39       |     7402     |   32         |
| T1. Statement Counters    | 444 |     147      |     14485    |   158        |
| T2. Duplicated Functions  | 305 |     69       |     9038     |   61         |
| T3. Decryption at place   | 323 |     79       |     9456     |   68         |
| T4. Duplicated variables  | 285 |     58       |     9278     |   65         |


On a **binary level** the hardening techniques introduce the following overhead:

**ARM architecture**


| Hardening technique       | Size (bytes) | Overhead (%) | Execution time (ms) |  Overhead (%) |
| ------------------------- | ------------ | ------------ | ------------------- | ------------- |
| Original (no harden.)     |    16448     |     n/a      |         52.4        |       n/a     |
| T0. Loop Hardening        |    17340     |     5        |         53.4        |       1.91    |
| T1. Statement Counters    |    24524     |     49       |         56.1        |       7.06    |
| T2. Duplicated Functions  |    17764     |     8        |         52.95       |       1.05    |
| T3. Decryption at place   |    17908     |     9        |         52.7        |       0.57    |
| T4. Duplicated variables  |    17652     |     7        |         52.3        |      -0.19    |


**Note**: execution time averaged across 20 runs with binaries compiled without optimization flags.






[1] ["Software countermeasures for control flow integrity of smart card C codes" Jean-François Lalande, Karine Heydemann, Pascal Berthomé](https://hal.inria.fr/hal-01059201/document)



**Old stuff (to be deleted later)**

Results

| Binary Type	   | # jumps | # binaries | # leaks |  size   
| ---------------- | ------- | ---------- | ------- | ------
| Original 	       |    37   |	   411    |    7    | 19116
| DupLoopCounter   |    45   |	   531    |    17   | 19236
| LoopCounterCheck |    62   |	   936    |    13   | 19612
| StmntCounter     |    366  |    19080   |    2    | 26628


**DupLoopCounter**: duplicated counters and exit conditions in sensitive loops. When compiled without optimisation flags, the loop counter instructions are indeed duplicated and present in assembly code. The problem, however, is that with more counters there are more jumps that can be faulted. This is proved by the results: compared with the original binary the hardened one has 8 more jumps; the Chaos Duck generates 531 faulty binaries from which 17 are leaking a plain text.

**LoopCounterCheck**: duplicated loop counters (where possible) and loop results check right after the loop. The check verifies the final value of the loop counter as well as a result of the loop (where possible). The hardened binary has more jumps and, hence, more faulty binaries can be generated by Chaos Duck. While the number of binaries leaking plain text is lower as compared with DupLoopCounter version, it is still 2x times more than the original binary. Clearly, the hardening technique makes things worse.

**StmntCounter**: implements a hardening technique proposed in [1]. All the source code statements are surrounded by the check for the instruction counter. After the execution of each statement the counter is incremented. This counter is then compared with the expected value after each function call, while/for loop or if-else statement. It distinguishes the statement counters of the nested loops and caller and callee functions -- these are counted separately. The authors of [1] claim that this technique aims to prevent "jump faults" attacks, since the maliciously modified jump target would be in conflict with the expected instruction counter value. The technique requires an automatic tool to annotate the source code with the statements counter checks. I did it manually for now (really prone to mistakes). Due to these annotations the size of the original binary increases significantly. The source code also becomes visibly cluttered and hard to debug. But the most important thing is that the technique indeed makes it harder to perform a jump fault attacks. Chaos Duck managed to generate only two binaries that were leaking sensitive data. For now, this technique is the best in terms of security results, but still not ideal.
